<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.4"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MultiSense Viewer: VulkanDevice Struct Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="logo.png"/></td>
  <td id="projectalign">
   <div id="projectname">MultiSense Viewer
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.4 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="structVulkanDevice-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">VulkanDevice Struct Reference</div></div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="VulkanDevice_8h_source.html">VulkanDevice.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a5268a366ddc3669217b45e5320865083"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structVulkanDevice.html#a5268a366ddc3669217b45e5320865083">VulkanDevice</a> (VkPhysicalDevice <a class="el" href="structVulkanDevice.html#afd64bfc97dfd1ab05e42b98cf15695cc">physicalDevice</a>)</td></tr>
<tr class="separator:a5268a366ddc3669217b45e5320865083"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1ebe200e9906eeb5a144efc3af29712"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structVulkanDevice.html#ab1ebe200e9906eeb5a144efc3af29712">~VulkanDevice</a> ()</td></tr>
<tr class="separator:ab1ebe200e9906eeb5a144efc3af29712"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbb5b59a3202b00e15130dd453afac9f"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structVulkanDevice.html#acbb5b59a3202b00e15130dd453afac9f">getMemoryType</a> (uint32_t typeBits, VkMemoryPropertyFlags <a class="el" href="structVulkanDevice.html#a7ca4390a8b2ddda99979168f8cba4194">properties</a>, VkBool32 *memTypeFound=nullptr) const</td></tr>
<tr class="separator:acbb5b59a3202b00e15130dd453afac9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a5d73107c807f4050a0b87951b1b207"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structVulkanDevice.html#a6a5d73107c807f4050a0b87951b1b207">getQueueFamilyIndex</a> (VkQueueFlagBits queueFlags) const</td></tr>
<tr class="separator:a6a5d73107c807f4050a0b87951b1b207"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a3f0dd2154415c12232a1e00e06e794"><td class="memItemLeft" align="right" valign="top">VkResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structVulkanDevice.html#a2a3f0dd2154415c12232a1e00e06e794">createLogicalDevice</a> (VkPhysicalDeviceFeatures <a class="el" href="structVulkanDevice.html#ad184b47c38ba3495760703e7618b69a6">enabledFeatures</a>, std::vector&lt; const char * &gt; enabledExtensions, void *pNextChain, bool useSwapChain=true, VkQueueFlags requestedQueueTypes=VK_QUEUE_GRAPHICS_BIT|VK_QUEUE_COMPUTE_BIT)</td></tr>
<tr class="separator:a2a3f0dd2154415c12232a1e00e06e794"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb694957d2558cdb76338e36c89de97f"><td class="memItemLeft" align="right" valign="top">VkCommandPool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structVulkanDevice.html#acb694957d2558cdb76338e36c89de97f">createCommandPool</a> (uint32_t queueFamilyIndex, VkCommandPoolCreateFlags createFlags=VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT)</td></tr>
<tr class="separator:acb694957d2558cdb76338e36c89de97f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae312ce7287bf33a8428a6476105bc1b5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structVulkanDevice.html#ae312ce7287bf33a8428a6476105bc1b5">extensionSupported</a> (std::string extension)</td></tr>
<tr class="separator:ae312ce7287bf33a8428a6476105bc1b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1fbed2c013a2c1b1daa5878166d570e"><td class="memItemLeft" align="right" valign="top">VkResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structVulkanDevice.html#ae1fbed2c013a2c1b1daa5878166d570e">createBuffer</a> (VkBufferUsageFlags usageFlags, VkMemoryPropertyFlags memoryPropertyFlags, VkDeviceSize size, VkBuffer *buffer, VkDeviceMemory *memory, void *data=nullptr)</td></tr>
<tr class="separator:ae1fbed2c013a2c1b1daa5878166d570e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bb6000170e57672a85065630d33b2dc"><td class="memItemLeft" align="right" valign="top">VkResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structVulkanDevice.html#a2bb6000170e57672a85065630d33b2dc">createBuffer</a> (VkBufferUsageFlags usageFlags, VkMemoryPropertyFlags memoryPropertyFlags, <a class="el" href="structBuffer.html">Buffer</a> *buffer, VkDeviceSize size, void *data=nullptr)</td></tr>
<tr class="separator:a2bb6000170e57672a85065630d33b2dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac64ec36f80254e4f2682f15250d8a8c5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structVulkanDevice.html#ac64ec36f80254e4f2682f15250d8a8c5">copyBuffer</a> (<a class="el" href="structBuffer.html">Buffer</a> *src, <a class="el" href="structBuffer.html">Buffer</a> *dst, VkQueue queue, VkBufferCopy *copyRegion=nullptr)</td></tr>
<tr class="separator:ac64ec36f80254e4f2682f15250d8a8c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a317c2e36fb3a94a13272e3283025e734"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structVulkanDevice.html#a317c2e36fb3a94a13272e3283025e734">copyVkBuffer</a> (VkBuffer *src, VkBuffer *dst, VkBufferCopy *copyRegion)</td></tr>
<tr class="memdesc:a317c2e36fb3a94a13272e3283025e734"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to copy data between VkBuffer.  <a href="structVulkanDevice.html#a317c2e36fb3a94a13272e3283025e734">More...</a><br /></td></tr>
<tr class="separator:a317c2e36fb3a94a13272e3283025e734"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a206ce9f14a3713153a90c68ce581cdc2"><td class="memItemLeft" align="right" valign="top">VkCommandBuffer&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structVulkanDevice.html#a206ce9f14a3713153a90c68ce581cdc2">createCommandBuffer</a> (VkCommandBufferLevel level, VkCommandPool pool, bool begin=false)</td></tr>
<tr class="separator:a206ce9f14a3713153a90c68ce581cdc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49ce8daffa074d9cd384e2faee7e2646"><td class="memItemLeft" align="right" valign="top">VkCommandBuffer&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structVulkanDevice.html#a49ce8daffa074d9cd384e2faee7e2646">createCommandBuffer</a> (VkCommandBufferLevel level, bool begin=false)</td></tr>
<tr class="separator:a49ce8daffa074d9cd384e2faee7e2646"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a2286bcc429345e9b7b961aeda5cbb7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structVulkanDevice.html#a7a2286bcc429345e9b7b961aeda5cbb7">beginCommandBuffer</a> (VkCommandBuffer commandBuffer)</td></tr>
<tr class="separator:a7a2286bcc429345e9b7b961aeda5cbb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5381391227513328f80cb9aba6e63281"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structVulkanDevice.html#a5381391227513328f80cb9aba6e63281">flushCommandBuffer</a> (VkCommandBuffer commandBuffer, VkQueue queue, VkCommandPool pool, bool free=true)</td></tr>
<tr class="separator:a5381391227513328f80cb9aba6e63281"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78b1166282e70aa8a8c1ad7b0a50e151"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structVulkanDevice.html#a78b1166282e70aa8a8c1ad7b0a50e151">flushCommandBuffer</a> (VkCommandBuffer commandBuffer, VkQueue queue, bool free=true)</td></tr>
<tr class="separator:a78b1166282e70aa8a8c1ad7b0a50e151"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-attribs" name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:afd64bfc97dfd1ab05e42b98cf15695cc"><td class="memItemLeft" align="right" valign="top">VkPhysicalDevice&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structVulkanDevice.html#afd64bfc97dfd1ab05e42b98cf15695cc">physicalDevice</a> {}</td></tr>
<tr class="memdesc:afd64bfc97dfd1ab05e42b98cf15695cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Physical device representation.  <a href="structVulkanDevice.html#afd64bfc97dfd1ab05e42b98cf15695cc">More...</a><br /></td></tr>
<tr class="separator:afd64bfc97dfd1ab05e42b98cf15695cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5996a53e9b9e2953a72fd7d1d185f1ea"><td class="memItemLeft" align="right" valign="top">VkDevice&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structVulkanDevice.html#a5996a53e9b9e2953a72fd7d1d185f1ea">logicalDevice</a> {}</td></tr>
<tr class="memdesc:a5996a53e9b9e2953a72fd7d1d185f1ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Logical device representation (application's view of the device)  <a href="structVulkanDevice.html#a5996a53e9b9e2953a72fd7d1d185f1ea">More...</a><br /></td></tr>
<tr class="separator:a5996a53e9b9e2953a72fd7d1d185f1ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96481e36371dbddeac06d43f3a9f209f"><td class="memItemLeft" align="right" valign="top">VkQueue&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structVulkanDevice.html#a96481e36371dbddeac06d43f3a9f209f">transferQueue</a> {}</td></tr>
<tr class="memdesc:a96481e36371dbddeac06d43f3a9f209f"><td class="mdescLeft">&#160;</td><td class="mdescRight">transfer queue for copy operations  <a href="structVulkanDevice.html#a96481e36371dbddeac06d43f3a9f209f">More...</a><br /></td></tr>
<tr class="separator:a96481e36371dbddeac06d43f3a9f209f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ca4390a8b2ddda99979168f8cba4194"><td class="memItemLeft" align="right" valign="top">VkPhysicalDeviceProperties&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structVulkanDevice.html#a7ca4390a8b2ddda99979168f8cba4194">properties</a> {}</td></tr>
<tr class="memdesc:a7ca4390a8b2ddda99979168f8cba4194"><td class="mdescLeft">&#160;</td><td class="mdescRight">Properties of the physical device including limits that the application can check against.  <a href="structVulkanDevice.html#a7ca4390a8b2ddda99979168f8cba4194">More...</a><br /></td></tr>
<tr class="separator:a7ca4390a8b2ddda99979168f8cba4194"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a146932ad129d5b0bf92df4f6e7bfeae0"><td class="memItemLeft" align="right" valign="top">VkPhysicalDeviceFeatures&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structVulkanDevice.html#a146932ad129d5b0bf92df4f6e7bfeae0">features</a> {}</td></tr>
<tr class="memdesc:a146932ad129d5b0bf92df4f6e7bfeae0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Features of the physical device that an application can use to check if a feature is supported.  <a href="structVulkanDevice.html#a146932ad129d5b0bf92df4f6e7bfeae0">More...</a><br /></td></tr>
<tr class="separator:a146932ad129d5b0bf92df4f6e7bfeae0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad184b47c38ba3495760703e7618b69a6"><td class="memItemLeft" align="right" valign="top">VkPhysicalDeviceFeatures&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structVulkanDevice.html#ad184b47c38ba3495760703e7618b69a6">enabledFeatures</a> {}</td></tr>
<tr class="memdesc:ad184b47c38ba3495760703e7618b69a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Features that have been enabled for use on the physical device.  <a href="structVulkanDevice.html#ad184b47c38ba3495760703e7618b69a6">More...</a><br /></td></tr>
<tr class="separator:ad184b47c38ba3495760703e7618b69a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5c0c3e50b6db98d4e32955da412e227"><td class="memItemLeft" align="right" valign="top">VkPhysicalDeviceMemoryProperties&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structVulkanDevice.html#ac5c0c3e50b6db98d4e32955da412e227">memoryProperties</a> {}</td></tr>
<tr class="memdesc:ac5c0c3e50b6db98d4e32955da412e227"><td class="mdescLeft">&#160;</td><td class="mdescRight">Memory types and heaps of the physical device.  <a href="structVulkanDevice.html#ac5c0c3e50b6db98d4e32955da412e227">More...</a><br /></td></tr>
<tr class="separator:ac5c0c3e50b6db98d4e32955da412e227"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9f5a6fdf30c7163f91ad20b2b9008ee"><td class="memItemLeft" align="right" valign="top">std::vector&lt; VkQueueFamilyProperties &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structVulkanDevice.html#ae9f5a6fdf30c7163f91ad20b2b9008ee">queueFamilyProperties</a> {}</td></tr>
<tr class="memdesc:ae9f5a6fdf30c7163f91ad20b2b9008ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Queue family properties of the physical device.  <a href="structVulkanDevice.html#ae9f5a6fdf30c7163f91ad20b2b9008ee">More...</a><br /></td></tr>
<tr class="separator:ae9f5a6fdf30c7163f91ad20b2b9008ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5ae599219fc3317a66f760355eb3b9f"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structVulkanDevice.html#aa5ae599219fc3317a66f760355eb3b9f">supportedExtensions</a> {}</td></tr>
<tr class="memdesc:aa5ae599219fc3317a66f760355eb3b9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">List of extensions supported by the device.  <a href="structVulkanDevice.html#aa5ae599219fc3317a66f760355eb3b9f">More...</a><br /></td></tr>
<tr class="separator:aa5ae599219fc3317a66f760355eb3b9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4d7c78a3f37bb9b32a47817431e25b1"><td class="memItemLeft" align="right" valign="top">VkCommandPool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structVulkanDevice.html#aa4d7c78a3f37bb9b32a47817431e25b1">commandPool</a> = VK_NULL_HANDLE</td></tr>
<tr class="memdesc:aa4d7c78a3f37bb9b32a47817431e25b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default command pool for the graphics queue family index.  <a href="structVulkanDevice.html#aa4d7c78a3f37bb9b32a47817431e25b1">More...</a><br /></td></tr>
<tr class="separator:aa4d7c78a3f37bb9b32a47817431e25b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae57f81d2f20bebfb44f31fb9fda0c992"><td class="memItemLeft" >struct {</td></tr>
<tr class="memitem:aca65b4e7b6eb6891ea1e7fc90a9a4de7"><td class="memItemLeft" >&#160;&#160;&#160;uint32_t&#160;&#160;&#160;<a class="el" href="structVulkanDevice.html#aaf188e088826d59b426b9296a15e79e1">graphics</a> {}</td></tr>
<tr class="separator:aca65b4e7b6eb6891ea1e7fc90a9a4de7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44b634adb61d83ff5f818ae33efb2900"><td class="memItemLeft" >&#160;&#160;&#160;uint32_t&#160;&#160;&#160;<a class="el" href="structVulkanDevice.html#a9f8cdbe6cbb043ed9fbdd40c52775d1f">compute</a> {}</td></tr>
<tr class="separator:a44b634adb61d83ff5f818ae33efb2900"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c2896d29fb6fcdb25cb2208a69392bc"><td class="memItemLeft" >&#160;&#160;&#160;uint32_t&#160;&#160;&#160;<a class="el" href="structVulkanDevice.html#aea4f66b0196328669dedc26a03b69cef">transfer</a> {}</td></tr>
<tr class="separator:a7c2896d29fb6fcdb25cb2208a69392bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae57f81d2f20bebfb44f31fb9fda0c992"><td class="memItemLeft" valign="top">}&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structVulkanDevice.html#ae57f81d2f20bebfb44f31fb9fda0c992">queueFamilyIndices</a></td></tr>
<tr class="memdesc:ae57f81d2f20bebfb44f31fb9fda0c992"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains queue family indices.  <a href="structVulkanDevice.html#ae57f81d2f20bebfb44f31fb9fda0c992">More...</a><br /></td></tr>
<tr class="separator:ae57f81d2f20bebfb44f31fb9fda0c992"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a5268a366ddc3669217b45e5320865083" name="a5268a366ddc3669217b45e5320865083"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5268a366ddc3669217b45e5320865083">&#9670;&nbsp;</a></span>VulkanDevice()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">VulkanDevice::VulkanDevice </td>
          <td>(</td>
          <td class="paramtype">VkPhysicalDevice&#160;</td>
          <td class="paramname"><em>physicalDevice</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab1ebe200e9906eeb5a144efc3af29712" name="ab1ebe200e9906eeb5a144efc3af29712"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1ebe200e9906eeb5a144efc3af29712">&#9670;&nbsp;</a></span>~VulkanDevice()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VulkanDevice::~VulkanDevice </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a7a2286bcc429345e9b7b961aeda5cbb7" name="a7a2286bcc429345e9b7b961aeda5cbb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a2286bcc429345e9b7b961aeda5cbb7">&#9670;&nbsp;</a></span>beginCommandBuffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void VulkanDevice::beginCommandBuffer </td>
          <td>(</td>
          <td class="paramtype">VkCommandBuffer&#160;</td>
          <td class="paramname"><em>commandBuffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac64ec36f80254e4f2682f15250d8a8c5" name="ac64ec36f80254e4f2682f15250d8a8c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac64ec36f80254e4f2682f15250d8a8c5">&#9670;&nbsp;</a></span>copyBuffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void VulkanDevice::copyBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structBuffer.html">Buffer</a> *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structBuffer.html">Buffer</a> *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkQueue&#160;</td>
          <td class="paramname"><em>queue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkBufferCopy *&#160;</td>
          <td class="paramname"><em>copyRegion</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Copy <a class="el" href="structBuffer.html" title="Encapsulates access to a Vulkan buffer backed up by device memory.">Buffer</a> data from src to dst using VkCmdCopyBuffer</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>Pointer to the source buffer to copy from </td></tr>
    <tr><td class="paramname">dst</td><td>Pointer to the destination buffer to copy to </td></tr>
    <tr><td class="paramname">queue</td><td>Pointer </td></tr>
    <tr><td class="paramname">copyRegion</td><td>(Optional) Pointer to a copy region, if NULL, the whole buffer is copied</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Source and destination pointers must have the appropriate transfer usage flags set (TRANSFER_SRC / TRANSFER_DST) </dd></dl>

</div>
</div>
<a id="a317c2e36fb3a94a13272e3283025e734" name="a317c2e36fb3a94a13272e3283025e734"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a317c2e36fb3a94a13272e3283025e734">&#9670;&nbsp;</a></span>copyVkBuffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void VulkanDevice::copyVkBuffer </td>
          <td>(</td>
          <td class="paramtype">VkBuffer *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkBuffer *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkBufferCopy *&#160;</td>
          <td class="paramname"><em>copyRegion</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to copy data between VkBuffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td><a class="el" href="structBuffer.html" title="Encapsulates access to a Vulkan buffer backed up by device memory.">Buffer</a> source to copy from </td></tr>
    <tr><td class="paramname">dst</td><td><a class="el" href="structBuffer.html" title="Encapsulates access to a Vulkan buffer backed up by device memory.">Buffer</a> to copy to </td></tr>
    <tr><td class="paramname">copyRegion</td><td>How much buffer to copy </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2bb6000170e57672a85065630d33b2dc" name="a2bb6000170e57672a85065630d33b2dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2bb6000170e57672a85065630d33b2dc">&#9670;&nbsp;</a></span>createBuffer() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VkResult VulkanDevice::createBuffer </td>
          <td>(</td>
          <td class="paramtype">VkBufferUsageFlags&#160;</td>
          <td class="paramname"><em>usageFlags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkMemoryPropertyFlags&#160;</td>
          <td class="paramname"><em>memoryPropertyFlags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structBuffer.html">Buffer</a> *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkDeviceSize&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Create a buffer on the device</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">usageFlags</td><td>Usage flag bit mask for the buffer (i.e. index, vertex, uniform buffer) </td></tr>
    <tr><td class="paramname">memoryPropertyFlags</td><td>Memory properties for this buffer (i.e. device local, host visible, coherent) </td></tr>
    <tr><td class="paramname">buffer</td><td>Pointer to a vk::Vulkan buffer object </td></tr>
    <tr><td class="paramname">size</td><td>Size of the buffer in bytes </td></tr>
    <tr><td class="paramname">data</td><td>Pointer to the data that should be copied to the buffer after creation (optional, if not set, no data is copied over)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>VK_SUCCESS if buffer handle and memory have been created and (optionally passed) data has been copied </dd></dl>

</div>
</div>
<a id="ae1fbed2c013a2c1b1daa5878166d570e" name="ae1fbed2c013a2c1b1daa5878166d570e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1fbed2c013a2c1b1daa5878166d570e">&#9670;&nbsp;</a></span>createBuffer() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VkResult VulkanDevice::createBuffer </td>
          <td>(</td>
          <td class="paramtype">VkBufferUsageFlags&#160;</td>
          <td class="paramname"><em>usageFlags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkMemoryPropertyFlags&#160;</td>
          <td class="paramname"><em>memoryPropertyFlags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkDeviceSize&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkBuffer *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkDeviceMemory *&#160;</td>
          <td class="paramname"><em>memory</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Create a buffer on the device</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">usageFlags</td><td>Usage flag bit mask for the buffer (i.e. index, vertex, uniform buffer) </td></tr>
    <tr><td class="paramname">memoryPropertyFlags</td><td>Memory properties for this buffer (i.e. device local, host visible, coherent) </td></tr>
    <tr><td class="paramname">size</td><td>Size of the buffer in byes </td></tr>
    <tr><td class="paramname">buffer</td><td>Pointer to the buffer handle acquired by the function </td></tr>
    <tr><td class="paramname">memory</td><td>Pointer to the memory handle acquired by the function </td></tr>
    <tr><td class="paramname">data</td><td>Pointer to the data that should be copied to the buffer after creation (optional, if not set, no data is copied over)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>VK_SUCCESS if buffer handle and memory have been created and (optionally passed) data has been copied </dd></dl>

</div>
</div>
<a id="a49ce8daffa074d9cd384e2faee7e2646" name="a49ce8daffa074d9cd384e2faee7e2646"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49ce8daffa074d9cd384e2faee7e2646">&#9670;&nbsp;</a></span>createCommandBuffer() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VkCommandBuffer VulkanDevice::createCommandBuffer </td>
          <td>(</td>
          <td class="paramtype">VkCommandBufferLevel&#160;</td>
          <td class="paramname"><em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>begin</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a206ce9f14a3713153a90c68ce581cdc2" name="a206ce9f14a3713153a90c68ce581cdc2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a206ce9f14a3713153a90c68ce581cdc2">&#9670;&nbsp;</a></span>createCommandBuffer() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VkCommandBuffer VulkanDevice::createCommandBuffer </td>
          <td>(</td>
          <td class="paramtype">VkCommandBufferLevel&#160;</td>
          <td class="paramname"><em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkCommandPool&#160;</td>
          <td class="paramname"><em>pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>begin</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Allocate a command buffer from the command pool</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">level</td><td>Level of the new command buffer (primary or secondary) </td></tr>
    <tr><td class="paramname">pool</td><td>Command pool from which the command buffer will be allocated </td></tr>
    <tr><td class="paramname">(Optional)</td><td>begin If true, recording on the new command buffer will be started (vkBeginCommandBuffer) (Defaults to false)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A handle to the allocated command buffer </dd></dl>

</div>
</div>
<a id="acb694957d2558cdb76338e36c89de97f" name="acb694957d2558cdb76338e36c89de97f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb694957d2558cdb76338e36c89de97f">&#9670;&nbsp;</a></span>createCommandPool()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VkCommandPool VulkanDevice::createCommandPool </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>queueFamilyIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkCommandPoolCreateFlags&#160;</td>
          <td class="paramname"><em>createFlags</em> = <code>VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Create a command pool for allocation command buffers from</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">queueFamilyIndex</td><td>Family index of the queue to create the command pool for </td></tr>
    <tr><td class="paramname">createFlags</td><td>(Optional) Command pool creation flags (Defaults to VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Command buffers allocated from the created pool can only be submitted to a queue with the same family index</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>A handle to the created command buffer </dd></dl>

</div>
</div>
<a id="a2a3f0dd2154415c12232a1e00e06e794" name="a2a3f0dd2154415c12232a1e00e06e794"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a3f0dd2154415c12232a1e00e06e794">&#9670;&nbsp;</a></span>createLogicalDevice()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VkResult VulkanDevice::createLogicalDevice </td>
          <td>(</td>
          <td class="paramtype">VkPhysicalDeviceFeatures&#160;</td>
          <td class="paramname"><em>enabledFeatures</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; const char * &gt;&#160;</td>
          <td class="paramname"><em>enabledExtensions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pNextChain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>useSwapChain</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkQueueFlags&#160;</td>
          <td class="paramname"><em>requestedQueueTypes</em> = <code>VK_QUEUE_GRAPHICS_BIT&#160;|&#160;VK_QUEUE_COMPUTE_BIT</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Create the logical device based on the assigned physical device, also gets default queue family indices</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">enabledFeatures</td><td>Can be used to enable certain features upon device creation </td></tr>
    <tr><td class="paramname">pNextChain</td><td>Optional chain of pointer to extension structures </td></tr>
    <tr><td class="paramname">useSwapChain</td><td>Set to false for headless rendering to omit the swapchain device extensions </td></tr>
    <tr><td class="paramname">requestedQueueTypes</td><td>Bit flags specifying the queue types to be requested from the device</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>VkResult of the device creation call </dd></dl>

</div>
</div>
<a id="ae312ce7287bf33a8428a6476105bc1b5" name="ae312ce7287bf33a8428a6476105bc1b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae312ce7287bf33a8428a6476105bc1b5">&#9670;&nbsp;</a></span>extensionSupported()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool VulkanDevice::extensionSupported </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>extension</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Check if an extension is supported by the (physical device)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">extension</td><td>Name of the extension to check</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the extension is supported (present in the list read at device creation time) </dd></dl>

</div>
</div>
<a id="a78b1166282e70aa8a8c1ad7b0a50e151" name="a78b1166282e70aa8a8c1ad7b0a50e151"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78b1166282e70aa8a8c1ad7b0a50e151">&#9670;&nbsp;</a></span>flushCommandBuffer() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void VulkanDevice::flushCommandBuffer </td>
          <td>(</td>
          <td class="paramtype">VkCommandBuffer&#160;</td>
          <td class="paramname"><em>commandBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkQueue&#160;</td>
          <td class="paramname"><em>queue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>free</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5381391227513328f80cb9aba6e63281" name="a5381391227513328f80cb9aba6e63281"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5381391227513328f80cb9aba6e63281">&#9670;&nbsp;</a></span>flushCommandBuffer() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void VulkanDevice::flushCommandBuffer </td>
          <td>(</td>
          <td class="paramtype">VkCommandBuffer&#160;</td>
          <td class="paramname"><em>commandBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkQueue&#160;</td>
          <td class="paramname"><em>queue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkCommandPool&#160;</td>
          <td class="paramname"><em>pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>free</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Finish command buffer recording and submit it to a queue</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">commandBuffer</td><td>Command buffer to flush </td></tr>
    <tr><td class="paramname">queue</td><td>Queue to submit the command buffer to </td></tr>
    <tr><td class="paramname">pool</td><td>Command pool on which the command buffer has been created </td></tr>
    <tr><td class="paramname">free</td><td>(Optional) Free the command buffer once it has been submitted (Defaults to true)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The queue that the command buffer is submitted to must be from the same family index as the pool it was allocated from </dd>
<dd>
Uses a fence to ensure command buffer has finished executing </dd></dl>

</div>
</div>
<a id="acbb5b59a3202b00e15130dd453afac9f" name="acbb5b59a3202b00e15130dd453afac9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbb5b59a3202b00e15130dd453afac9f">&#9670;&nbsp;</a></span>getMemoryType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t VulkanDevice::getMemoryType </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>typeBits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkMemoryPropertyFlags&#160;</td>
          <td class="paramname"><em>properties</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkBool32 *&#160;</td>
          <td class="paramname"><em>memTypeFound</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Get the index of a memory type that has all the requested property bits set</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">typeBits</td><td>Bit mask with bits set for each memory type supported by the resource to request for (from VkMemoryRequirements) </td></tr>
    <tr><td class="paramname">properties</td><td>Bit mask of properties for the memory type to request </td></tr>
    <tr><td class="paramname">(Optional)</td><td>memTypeFound Pointer to a bool that is set to true if a matching memory type has been found</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Index of the requested memory type</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">Throws</td><td>an exception if memTypeFound is null and no memory type could be found that supports the requested properties </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6a5d73107c807f4050a0b87951b1b207" name="a6a5d73107c807f4050a0b87951b1b207"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a5d73107c807f4050a0b87951b1b207">&#9670;&nbsp;</a></span>getQueueFamilyIndex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t VulkanDevice::getQueueFamilyIndex </td>
          <td>(</td>
          <td class="paramtype">VkQueueFlagBits&#160;</td>
          <td class="paramname"><em>queueFlags</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Get the index of a queue family that supports the requested queue flags</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">queueFlags</td><td>Queue flags to find a queue family index for</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Index of the queue family index that matches the flags</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">Throws</td><td>an exception if no queue family index could be found that supports the requested flags </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="aa4d7c78a3f37bb9b32a47817431e25b1" name="aa4d7c78a3f37bb9b32a47817431e25b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4d7c78a3f37bb9b32a47817431e25b1">&#9670;&nbsp;</a></span>commandPool</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VkCommandPool VulkanDevice::commandPool = VK_NULL_HANDLE</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Default command pool for the graphics queue family index. </p>

</div>
</div>
<a id="a9f8cdbe6cbb043ed9fbdd40c52775d1f" name="a9f8cdbe6cbb043ed9fbdd40c52775d1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f8cdbe6cbb043ed9fbdd40c52775d1f">&#9670;&nbsp;</a></span>compute</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t VulkanDevice::compute {}</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad184b47c38ba3495760703e7618b69a6" name="ad184b47c38ba3495760703e7618b69a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad184b47c38ba3495760703e7618b69a6">&#9670;&nbsp;</a></span>enabledFeatures</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VkPhysicalDeviceFeatures VulkanDevice::enabledFeatures {}</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Features that have been enabled for use on the physical device. </p>

</div>
</div>
<a id="a146932ad129d5b0bf92df4f6e7bfeae0" name="a146932ad129d5b0bf92df4f6e7bfeae0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a146932ad129d5b0bf92df4f6e7bfeae0">&#9670;&nbsp;</a></span>features</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VkPhysicalDeviceFeatures VulkanDevice::features {}</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Features of the physical device that an application can use to check if a feature is supported. </p>

</div>
</div>
<a id="aaf188e088826d59b426b9296a15e79e1" name="aaf188e088826d59b426b9296a15e79e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf188e088826d59b426b9296a15e79e1">&#9670;&nbsp;</a></span>graphics</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t VulkanDevice::graphics {}</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5996a53e9b9e2953a72fd7d1d185f1ea" name="a5996a53e9b9e2953a72fd7d1d185f1ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5996a53e9b9e2953a72fd7d1d185f1ea">&#9670;&nbsp;</a></span>logicalDevice</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VkDevice VulkanDevice::logicalDevice {}</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Logical device representation (application's view of the device) </p>

</div>
</div>
<a id="ac5c0c3e50b6db98d4e32955da412e227" name="ac5c0c3e50b6db98d4e32955da412e227"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5c0c3e50b6db98d4e32955da412e227">&#9670;&nbsp;</a></span>memoryProperties</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VkPhysicalDeviceMemoryProperties VulkanDevice::memoryProperties {}</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Memory types and heaps of the physical device. </p>

</div>
</div>
<a id="afd64bfc97dfd1ab05e42b98cf15695cc" name="afd64bfc97dfd1ab05e42b98cf15695cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd64bfc97dfd1ab05e42b98cf15695cc">&#9670;&nbsp;</a></span>physicalDevice</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VkPhysicalDevice VulkanDevice::physicalDevice {}</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Physical device representation. </p>

</div>
</div>
<a id="a7ca4390a8b2ddda99979168f8cba4194" name="a7ca4390a8b2ddda99979168f8cba4194"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ca4390a8b2ddda99979168f8cba4194">&#9670;&nbsp;</a></span>properties</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VkPhysicalDeviceProperties VulkanDevice::properties {}</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Properties of the physical device including limits that the application can check against. </p>

</div>
</div>
<a id="ae57f81d2f20bebfb44f31fb9fda0c992" name="ae57f81d2f20bebfb44f31fb9fda0c992"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae57f81d2f20bebfb44f31fb9fda0c992">&#9670;&nbsp;</a></span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct  { ... }  VulkanDevice::queueFamilyIndices</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Contains queue family indices. </p>

</div>
</div>
<a id="ae9f5a6fdf30c7163f91ad20b2b9008ee" name="ae9f5a6fdf30c7163f91ad20b2b9008ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9f5a6fdf30c7163f91ad20b2b9008ee">&#9670;&nbsp;</a></span>queueFamilyProperties</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;VkQueueFamilyProperties&gt; VulkanDevice::queueFamilyProperties {}</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Queue family properties of the physical device. </p>

</div>
</div>
<a id="aa5ae599219fc3317a66f760355eb3b9f" name="aa5ae599219fc3317a66f760355eb3b9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5ae599219fc3317a66f760355eb3b9f">&#9670;&nbsp;</a></span>supportedExtensions</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::string&gt; VulkanDevice::supportedExtensions {}</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>List of extensions supported by the device. </p>

</div>
</div>
<a id="aea4f66b0196328669dedc26a03b69cef" name="aea4f66b0196328669dedc26a03b69cef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea4f66b0196328669dedc26a03b69cef">&#9670;&nbsp;</a></span>transfer</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t VulkanDevice::transfer {}</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a96481e36371dbddeac06d43f3a9f209f" name="a96481e36371dbddeac06d43f3a9f209f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96481e36371dbddeac06d43f3a9f209f">&#9670;&nbsp;</a></span>transferQueue</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VkQueue VulkanDevice::transferQueue {}</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>transfer queue for copy operations </p>

</div>
</div>
<hr/>The documentation for this struct was generated from the following files:<ul>
<li>/home/magnus/CLionProjects/MultiSense/src/core/<a class="el" href="VulkanDevice_8h_source.html">VulkanDevice.h</a></li>
<li>/home/magnus/CLionProjects/MultiSense/src/core/<a class="el" href="VulkanDevice_8cpp.html">VulkanDevice.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.4
</small></address>
</body>
</html>
